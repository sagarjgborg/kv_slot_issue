const locks = new Map();
/**
 * Only allow one instance of the callback to run at a time for a given `scope` and `key`.
 */
export async function withLock(scope, key, callback) {
    while (locks.get(scope)?.has(key)) {
        await locks.get(scope)?.get(key);
    }
    const promise = callback();
    if (!locks.has(scope))
        locks.set(scope, new Map());
    locks.get(scope).set(key, promise);
    try {
        return await promise;
    }
    finally {
        locks.get(scope)?.delete(key);
        if (locks.get(scope)?.size === 0)
            locks.delete(scope);
    }
}
/**
 * Check if a lock is currently active for a given `scope` and `key`.
 */
export function isLockActive(scope, key) {
    return locks.get(scope)?.has(key) ?? false;
}
/**
 * Acquire a lock for a given `scope` and `key`.
 */
export async function acquireLock(scope, key) {
    let releaseLock;
    await new Promise((accept) => {
        void withLock(scope, key, async () => {
            accept(null);
            await new Promise((accept) => {
                releaseLock = accept;
            });
        });
    });
    return {
        scope,
        key,
        dispose() {
            releaseLock(null);
        },
        [Symbol.dispose]() {
            releaseLock(null);
        }
    };
}
//# sourceMappingURL=withLock.js.map